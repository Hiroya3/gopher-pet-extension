<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'none';
        img-src {{cspSource}};
        style-src 'unsafe-inline';
        script-src 'unsafe-inline';
    ">
</head>

<body>
    <div id="game-container">
        <img id="gopher" src="{{gopherUri}}" alt="Gopher Pet">
        <div id="stone-container"></div>
        <div id="score-display">Score: 0</div>
        <div id="countdown" class="hidden"></div>
        <div id="game-over" class="hidden">
            <div>Game Over!</div>
            <div id="final-score"></div>
            <div>Press Space to restart</div>
            <div class="exit-hint">Press Esc to exit</div>
        </div>
    </div>
</body>

<style>
    body {
        margin: 0;
        padding: 0;
        height: 100vh;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        overflow: hidden;

        background-image: url('{{backgroundUri}}');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }

    #game-container {
        position: relative;
        width: 100%;
        height: 100%;
    }

    #gopher {
        width: 60px;
        z-index: 2;
        position: absolute;
        bottom: 0;
    }

    .stone {
        width: 40px;
        height: 40px;
        position: absolute;
        bottom: 0;
        z-index: 1;
    }

    .game-mode {
        left: 30px !important;
        transform: none !important;
    }

    .impact {
        position: absolute;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255,255,0,0.8) 0%, rgba(255,100,0,0.4) 50%, transparent 70%);
        pointer-events: none;
        z-index: 10;
    }

    #score-display {
        position: absolute;
        top: 10px;
        right: 10px;
        color: white;
        font-family: sans-serif;
        font-size: 16px;
        font-weight: bold;
        text-shadow: 1px 1px 2px black;
        display: none;
    }

    #score-display.visible {
        display: block;
    }

    #game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-family: sans-serif;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        text-shadow: 2px 2px 4px black;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 10px;
    }

    #game-over.hidden {
        display: none;
    }

    #final-score {
        margin: 10px 0;
    }

    .exit-hint {
        margin-top: 10px;
        font-size: 14px;
        opacity: 0.7;
    }

    #countdown {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-family: sans-serif;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        text-shadow: 2px 2px 4px black;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 10px;
    }

    #countdown.hidden {
        display: none;
    }
</style>

<script>
    const vscode = acquireVsCodeApi();
    const gopher = document.getElementById('gopher');
    const gameContainer = document.getElementById('game-container');
    const stoneContainer = document.getElementById('stone-container');
    const scoreDisplay = document.getElementById('score-display');
    const gameOverDisplay = document.getElementById('game-over');
    const finalScoreDisplay = document.getElementById('final-score');
    const countdownDisplay = document.getElementById('countdown');
    const stoneImageSrc = '{{stoneUri}}';
    const gopherRunningSrc = '{{gopherUri}}';
    const gopherSpinningSrc = '{{spinningUri}}';

    // Animation utility function
    function animate(duration, updateFn, easingFn = (t) => t) {
        let startTime = null;
        let animationId = null;
        let cancelled = false;

        function tick(currentTime) {
            if (cancelled) return;
            if (startTime === null) startTime = currentTime;
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            updateFn(easingFn(progress));

            if (progress < 1) {
                animationId = requestAnimationFrame(tick);
            }
        }

        animationId = requestAnimationFrame(tick);
        return {
            cancel: () => {
                cancelled = true;
                if (animationId) cancelAnimationFrame(animationId);
            }
        };
    }

    // Easing functions
    const easing = {
        linear: (t) => t,
        easeOut: (t) => 1 - Math.pow(1 - t, 3)
    };

    // Animation state tracking
    let runAnimationId = null;
    let jumpAnimation = null;
    let hitSpinAnimation = null;
    let screenShakeAnimation = null;

    let gameMode = false;
    let isJumping = false;
    let gameRunning = false;
    let isCountingDown = false;
    let waitingForStart = false;
    let score = 0;
    let stoneInterval = null;
    let collisionCheckInterval = null;
    let stones = [];

    // Idle run animation (gopher runs left to right continuously)
    function startRunAnimation() {
        let startTime = null;
        const duration = 10000; // 10 seconds

        function tick(currentTime) {
            if (gameMode) {
                runAnimationId = null;
                return;
            }
            if (startTime === null) startTime = currentTime;

            const containerWidth = gameContainer.offsetWidth;
            const gopherWidth = gopher.offsetWidth || 60;
            const progress = ((currentTime - startTime) % duration) / duration;
            const startX = -gopherWidth;
            const endX = containerWidth + gopherWidth;
            const x = startX + ((endX - startX) * progress);

            gopher.style.transform = `translateX(${x}px)`;
            runAnimationId = requestAnimationFrame(tick);
        }

        runAnimationId = requestAnimationFrame(tick);
    }

    function stopRunAnimation() {
        if (runAnimationId) {
            cancelAnimationFrame(runAnimationId);
            runAnimationId = null;
        }
        gopher.style.transform = '';
    }

    window.addEventListener('message', event => {
        const message = event.data;
        if (message.type === 'startGame') {
            startGame();
        }
    });

    function startGame() {
        gameMode = true;
        waitingForStart = true;
        score = 0;
        updateScore();

        // Stop idle animation
        stopRunAnimation();

        gopher.src = gopherRunningSrc;
        gopher.classList.add('game-mode');

        // Reset any transform from previous animations
        gopher.style.transform = '';
        gopher.style.bottom = '0';
        gameContainer.style.transform = '';

        scoreDisplay.classList.add('visible');
        gameOverDisplay.classList.add('hidden');

        // Clear existing stones and their animations
        stones.forEach(stone => {
            if (stone.animation) stone.animation.cancel();
            stone.element.remove();
        });
        stones = [];

        // Show prompt to press space
        countdownDisplay.textContent = 'Press Space to Start';
        countdownDisplay.classList.remove('hidden');
    }

    function showCountdown() {
        isCountingDown = true;
        countdownDisplay.classList.remove('hidden');

        let count = 3;
        countdownDisplay.textContent = count;

        const countdownInterval = setInterval(() => {
            count--;
            if (count > 0) {
                countdownDisplay.textContent = count;
            } else {
                clearInterval(countdownInterval);
                countdownDisplay.classList.add('hidden');
                isCountingDown = false;
                beginGameplay();
            }
        }, 1000);
    }

    function beginGameplay() {
        gameRunning = true;

        // Start spawning stones
        spawnStone();
        stoneInterval = setInterval(spawnStone, 1500 + Math.random() * 1000);

        // Start collision detection
        collisionCheckInterval = setInterval(checkCollision, 50);
    }

    function stopGame() {
        gameRunning = false;
        if (stoneInterval) {
            clearInterval(stoneInterval);
            stoneInterval = null;
        }
        if (collisionCheckInterval) {
            clearInterval(collisionCheckInterval);
            collisionCheckInterval = null;
        }

        // Switch to spinning gopher on collision
        gopher.src = gopherSpinningSrc;

        // Play JavaScript animations
        playHitSpinAnimation();
        playScreenShake();

        // Create impact flash effect at gopher position
        const gopherRect = gopher.getBoundingClientRect();
        const containerRect = gameContainer.getBoundingClientRect();
        const impactX = gopherRect.left - containerRect.left + gopherRect.width / 2 - 30;
        createImpactFlash(impactX, 20);

        // Show game over after spin animation
        setTimeout(() => {
            finalScoreDisplay.textContent = 'Score: ' + score;
            gameOverDisplay.classList.remove('hidden');
        }, 800);
    }

    function exitGame() {
        // Stop game intervals
        gameRunning = false;
        gameMode = false;
        if (stoneInterval) {
            clearInterval(stoneInterval);
            stoneInterval = null;
        }
        if (collisionCheckInterval) {
            clearInterval(collisionCheckInterval);
            collisionCheckInterval = null;
        }

        // Cancel any active animations
        if (hitSpinAnimation) {
            hitSpinAnimation.cancel();
            hitSpinAnimation = null;
        }
        if (screenShakeAnimation) {
            screenShakeAnimation.cancel();
            screenShakeAnimation = null;
        }
        if (jumpAnimation) {
            jumpAnimation.cancel();
            jumpAnimation = null;
        }

        // Clear all stones and their animations
        stones.forEach(stone => {
            if (stone.animation) stone.animation.cancel();
            stone.element.remove();
        });
        stones = [];

        // Reset gopher styles
        gopher.src = gopherRunningSrc;
        gopher.classList.remove('game-mode');
        gopher.style.transform = '';
        gopher.style.bottom = '0';
        gameContainer.style.transform = '';

        // Hide game UI
        scoreDisplay.classList.remove('visible');
        gameOverDisplay.classList.add('hidden');
        countdownDisplay.classList.add('hidden');

        // Reset state
        isJumping = false;
        isCountingDown = false;
        waitingForStart = false;
        score = 0;

        // Restart idle running animation
        startRunAnimation();
    }

    function spawnStone() {
        if (!gameRunning) return;

        const stone = document.createElement('img');
        stone.src = stoneImageSrc;
        stone.className = 'stone';
        stone.style.right = '-40px';
        stoneContainer.appendChild(stone);

        const stoneObj = {
            element: stone,
            passed: false,
            animation: null
        };
        stones.push(stoneObj);

        // Animate stone from right to left using JavaScript
        const duration = 2000; // 2 seconds
        const containerWidth = stoneContainer.offsetWidth;
        const startRight = -40;
        const endRight = containerWidth + 40;

        stoneObj.animation = animate(duration, (progress) => {
            const currentRight = startRight + ((endRight - startRight) * progress);
            stone.style.right = currentRight + 'px';
        }, easing.linear);

        // Handle animation completion
        setTimeout(() => {
            if (!stoneObj.passed && gameRunning) {
                score++;
                updateScore();
                stoneObj.passed = true;
            }
            stone.remove();
            stones = stones.filter(s => s !== stoneObj);
        }, duration);
    }

    function updateScore() {
        scoreDisplay.textContent = 'Score: ' + score;
    }

    function checkCollision() {
        if (!gameRunning) return;

        const gopherRect = gopher.getBoundingClientRect();

        for (const stoneObj of stones) {
            const stoneRect = stoneObj.element.getBoundingClientRect();

            // Check for collision (with some padding for fairness)
            const padding = 10;
            if (
                gopherRect.left + padding < stoneRect.right - padding &&
                gopherRect.right - padding > stoneRect.left + padding &&
                gopherRect.bottom - padding > stoneRect.top + padding &&
                gopherRect.top + padding < stoneRect.bottom - padding
            ) {
                stopGame();
                return;
            }
        }
    }

    document.addEventListener('keydown', (event) => {
        if (event.code === 'Escape' && gameMode) {
            event.preventDefault();
            exitGame();
        } else if (event.code === 'Space') {
            event.preventDefault();

            // Block input during countdown
            if (isCountingDown) {
                return;
            }

            if (waitingForStart) {
                // Start countdown when waiting
                waitingForStart = false;
                showCountdown();
            } else if (gameMode && !gameRunning) {
                // Restart game (go back to waiting state)
                startGame();
            } else if (gameMode && !isJumping) {
                jump();
            }
        }
    });

    function jump() {
        if (isJumping) return;

        isJumping = true;
        const jumpHeight = 100;
        const jumpUpDuration = 300;
        const jumpDownDuration = 200;

        // Jump up
        jumpAnimation = animate(jumpUpDuration, (progress) => {
            const height = jumpHeight * progress;
            gopher.style.bottom = height + 'px';
        }, easing.easeOut);

        // After reaching peak, fall down
        setTimeout(() => {
            jumpAnimation = animate(jumpDownDuration, (progress) => {
                const height = jumpHeight * (1 - progress);
                gopher.style.bottom = height + 'px';
            }, easing.linear);

            setTimeout(() => {
                gopher.style.bottom = '0';
                isJumping = false;
            }, jumpDownDuration);
        }, jumpUpDuration);
    }

    // Collision animation: Hit spin (gopher spins on collision)
    function playHitSpinAnimation() {
        const duration = 800;
        const totalRotation = 1800; // 5 full rotations

        // Y keyframes: [0, -50, -80, -60, -20, 0] at [0%, 20%, 40%, 60%, 80%, 100%]
        const yKeyframes = [
            { time: 0, value: 0 },
            { time: 0.2, value: -50 },
            { time: 0.4, value: -80 },
            { time: 0.6, value: -60 },
            { time: 0.8, value: -20 },
            { time: 1, value: 0 }
        ];

        function interpolateY(progress) {
            for (let i = 0; i < yKeyframes.length - 1; i++) {
                const current = yKeyframes[i];
                const next = yKeyframes[i + 1];
                if (progress >= current.time && progress <= next.time) {
                    const localProgress = (progress - current.time) / (next.time - current.time);
                    return current.value + (next.value - current.value) * localProgress;
                }
            }
            return 0;
        }

        hitSpinAnimation = animate(duration, (progress) => {
            const rotation = totalRotation * progress;
            const yOffset = interpolateY(progress);
            gopher.style.transform = `rotate(${rotation}deg) translateY(${yOffset}px)`;
        }, easing.easeOut);
    }

    // Collision animation: Screen shake
    function playScreenShake() {
        const duration = 400;

        const shakeKeyframes = [
            { time: 0, value: 0 },
            { time: 0.1, value: -10 },
            { time: 0.2, value: 10 },
            { time: 0.3, value: -8 },
            { time: 0.4, value: 8 },
            { time: 0.5, value: -5 },
            { time: 0.6, value: 5 },
            { time: 0.7, value: -3 },
            { time: 0.8, value: 3 },
            { time: 0.9, value: -1 },
            { time: 1, value: 0 }
        ];

        function interpolateShake(progress) {
            for (let i = 0; i < shakeKeyframes.length - 1; i++) {
                const current = shakeKeyframes[i];
                const next = shakeKeyframes[i + 1];
                if (progress >= current.time && progress <= next.time) {
                    const localProgress = (progress - current.time) / (next.time - current.time);
                    return current.value + (next.value - current.value) * localProgress;
                }
            }
            return 0;
        }

        screenShakeAnimation = animate(duration, (progress) => {
            const xOffset = interpolateShake(progress);
            gameContainer.style.transform = `translateX(${xOffset}px)`;
        }, easing.linear);

        setTimeout(() => {
            gameContainer.style.transform = '';
        }, duration);
    }

    // Collision animation: Impact flash
    function createImpactFlash(x, y) {
        const impact = document.createElement('div');
        impact.className = 'impact';
        impact.style.left = x + 'px';
        impact.style.bottom = y + 'px';
        impact.style.opacity = '0';
        impact.style.transform = 'scale(0.5)';
        gameContainer.appendChild(impact);

        const duration = 300;

        animate(duration, (progress) => {
            let opacity, scale;

            if (progress < 0.5) {
                const localProgress = progress / 0.5;
                opacity = localProgress;
                scale = 0.5 + (1.0 * localProgress);
            } else {
                const localProgress = (progress - 0.5) / 0.5;
                opacity = 1 - localProgress;
                scale = 1.5 + (0.5 * localProgress);
            }

            impact.style.opacity = opacity.toString();
            impact.style.transform = `scale(${scale})`;
        }, easing.easeOut);

        setTimeout(() => {
            impact.remove();
        }, duration);
    }

    // Initialize idle animation on load
    startRunAnimation();

    window.focus();
</script>

</html>
